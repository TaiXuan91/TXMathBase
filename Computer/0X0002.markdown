# C 实践指南

学习编程不能仅仅是研究语言语法，也需要做实验来实践。这一期我们来介绍一些在实践 C 编程时可能用到的工具。

在正式开始之前，我们需要做一些说明。对于大部分优秀的工具来说，一般都会带有详细的说明文档，仔细阅读这些说明文档是高效正确地使用这些工具的前提。但同时，我们也可以通过阅读或观看别人制作的教程来学习使用这些工具。说明文档和教程的区别在于：说明文档力求全面，而且以工具功能的内在逻辑为内容编排顺序；而教程则以最基础和最常用的功能为主，以循序渐进的学习顺序编排内容。

如果同时有教程和文档的情况下，建议先学习教程对工具有一个大概的了解，然后浏览一遍文档，对工具的各种功能有一个印象，在具体使用时再去文档中查询不清楚的部分。

## C 的实现

之前我们介绍的 C 主要是以 C 的标准为主，也就是说书上更多告诉我们 C 应当是怎样。但实际我们要用 C 编程，需要用到这门语言的实现。我认为，对一门编程语言来说，它的实现主要包括两个方面：

1. 一门编程语言最终要转换到为目标计算机能够执行的机器码，这个转换过程可以笼统称为“编译”。实现语言的第一步就是要有按照语言标准自动编译语言源码的工具。
1. 一门语言往往包含定义好的标准库。实现语言也要在对应的计算机平台上实现可用的标准库。

### 编译工具链

C 的编译分为很多步骤，一般书上按预处理、编译（从 C 语言编译为汇编语言或中间代码）、汇编（从汇编语言到机器码）、链接四个步骤讲解。在类 Unix 系统上的实现里，编译中的每一个步骤都由一个单独的工具完成，最后由一个编译引擎调用各个组件完成整个编译工作。

在 Linux 系统中常用的 GCC 实际上是好几个工具的套件。首先它包含一个编译预处理工具和一个编译工具，并且还带有一个编译引擎。而单独的汇编工具和链接工具则由 GNU 计划的另一个软件包 GNU Binutils 提供。此外 GNU Binutils 还提供一些对二进制文件进行操作和检查的工具。因此，要在 Linux 上完成一个常规软件的编译，至少需要安装这两个软件包：

* the GNU Compiler Collection (GCC)

GCC 是类 Unix 系统中的主要 C 编译器之一。利用它可以把 C 的源码转化为可执行文件。大致的转化流程参见 *Expert C Programming* 等书。其详尽用法参见 GCC 官方手册。

GCC 的官网地址是 <https://www.gnu.org/software/gcc/>。

* GNU Binutils

GCC 是一个编译工具集，在调用 GCC 的时候它会自动调用一系列工具完成编译。如果需要单独使用编译过程中的部分工具或者使用一些二进制文件工具检查生成的可执行文件，你就需要用到 GNU Binutils 了。其中比较常用的组件有`ar`和`ld`。`ar`是二进制文件归档工具，用于创建静态库，`ld`则是链接器（链接器的作用详见 *Expert C Programming* 等书），可用于创建动态库。详尽的使用说明同样见其官方手册。

GNU Binutils的官网地址是 <https://www.gnu.org/software/binutils/>。

### 标准库实现

编译工具实现语言的编译链接，但巧妇难为无米之炊，几乎每个程序都要链接的标准库却不是由编译器本身实现的。这就引出了 glibc。

* the GNU C Library (glibc)

GCC 和 GNU Binutils 只是 C 的编译链接工具，它们负责将源码转化为可执行文件但 C 的标准库却不由它们实现。GNU 计划中的 GNU C Library 则负责实现 C 标准中的库函数供 GCC 或 `ld` 往编译后的代码中链接。

需要注意的是，C 标准库其实只是 glibc 内容的一部分。glibc 除了实现 ISO C 标准库，还实现了 POSIX 系统接口、BSD 接口等，详见其文档。

glibc 的官网地址为 <https://www.gnu.org/software/libc/>。

### 阅读资料

* *Hagen, W.* (2006). **The Definitive Guide to GCC**

这本书书名中说的是介绍 GCC 但实际上对 GNU Binutils 和 glibc 等也有介绍。书中介绍的内容远超过学习 C 语言初期所需要的内容（例如介绍了交叉编译、autotools、GNU 工具链的编译等），因此这本书不必强求一次读完。首先学会用 GCC 编译自己的实验代码，等完成 C 语言和标准库的大部分学习内容后再回头研究它也可以。

## 代码检查

这里的代码检查主要指针对 C 标准以外的代码风格规范进行检查。代码风格一般不影响程序的编译运行，但可以帮助程序员减少错误，提高代码可读性以及降低维护成本。

从逻辑上来说，代码检查工具其实应该放到编译套件中（因为代码检查也需要进行词法分析和语法分析）。但当初 GCC 的实现者出于拆分功能等考虑，把代码检查从编译器中分了出去（这就很搞笑，既然要拆分功能为什么 GCC 到现在还是一个巨无霸），这就导致很多人实际上不再使用代码检查器。所以，在这里推荐一款代码检查工具，希望读者们在写好代码之后用检查器对代码风格进行一下检查。

* Splint

仅仅根据源码文件对代码进行检查（不涉及代码运行时状态的），叫做静态检查。这个概念在 UNIX 时代就有，当时 UNIX 系统上有一款静态检查工具叫 lint。后来有人做了一个更为现代的代码检查工具叫 LCLint （也叫 LCL），改名之后就是现在的Splint。它的用法很简答，把要检查的源文件当作`splint`命令的输入，Splint 就会将不符合预设风格的地方用类似编译警告的形式输出（但 Splint 本身并不会编译代码）。更多信息详见 Splint 官网。

Splint的官网地址为 <http://splint.org/>。

## 构建管理

用 GCC 之类的编译器编译 C 程序看似是一件很方便的事情，只需要一行命令就能获得一个编译结果。但是随着程序复杂度的上升，往往源码文件数量、目标文件数量和文件之间的依赖关系会越来越复杂。这时候编译整个工程就需要敲很多命令。一个省事的办法就是把这些命令写成一个 Shell 脚本，这样就不需要每次手动敲命令。但随着命令的增多就会发现，这些命令之间其实存在大量重复，例如几乎每一条命令都要写一个`gcc`。当年的 C 程序员想出来一个更懒的办法，就是写了一个名为`Makefile`的文件用于记录项目中文件之间的依赖关系，然后写了一个名为`make`的工具，让`make`根据`Makefile`的记录自动生成并执行编译命令。

但是当项目变得更大时，`Makefile`也越写越大，而且由于为了保持代码的跨平台性，往往要在编译之前完成一系列的配置。这就让编写`Makefile`本身变成了一个更加复杂的事情。于是程序员们会写一个名为`configure`的 Shell 脚本，让它根据环境和要求对`Makefile`进行配置。可以想象，很快`configure`也变得越来越难写，于是又发明了一堆工具来自动生成`configure`。在 GNU 工具链中，这套生成`configure`的工具叫 Autotools，主要包括 GNU Autoconf，GNU Autoconf Archive，GNU Automake 和 GNU Libtool。个人建议学一学基本的 GNU Make，然后对 Autotools 做一个大致了解即可。

> 对于一门现代语言来说，其构建系统以及包管理应该是其标准和实现的一部分。但在 C 那个年代这些概念甚至还没有没提出来，所以 C 的构建工具十分混乱。而这也是我不推荐写 C 的原因之一。

* GNU Make

GNU 计划实现的`make`程序，是类 Unix 系统中 C 项目构建管理的核心。但本质上只是一个内建了文件依赖检查的脚本解释器，个人感觉这种模式已经慢慢不适合于现代的项目管理。但由于习惯因素，目前在 Linux 系统中还是主要用 GNU Make 来构建 C 程序。

GNU Make 的官网为 <https://www.gnu.org/software/make/>。

* GNU Autoconf

用于扫描项目和系统，生成配置的工具。其官网地址为 <https://www.gnu.org/software/autoconf/>。

* GNU Autoconf Archive

GNU Autoconf 用到了宏展开，这个软件则是一些预先写好的可复用宏的合集。其官网地址为 <https://www.gnu.org/software/autoconf-archive/>。

* GNU Automake

用于根据用户配置生成`Makefile`。其官网地址为 <https://www.gnu.org/software/automake/>。

* GNU Libtool

虽然以`lib`开头，但这并不是一个库文件（GNU 自己打破了命名约定），它是一个自动生成和管理库的工具。其官网地址为 <https://www.gnu.org/software/libtool/>。

### 阅读资料

* *Mecklenburg, R.* (2004). **Managing projects with GNU make**

这本书对于 GNU make 的介绍非常详尽，而且还配有很多使用实例（虽然用 GNU make 编译 Java 这类例子平常基本用不到）。个人认为单学习 GNU make 本身的话读这本书就差不多了，如果觉得不够就再读读 GNU make 的文档或者找一些优质开源项目，看看它们的 Makefile。

如果想要大致了解 Autotools，可以阅读 *The Definitive Guide to GCC* 中的有关章节。另外，在学习这些“自动化”构建工具的时候，会涉及到 Shell 脚本，perl 和 m4，但这些都不在这篇文章中详细介绍。

## 调试工具

调试不是程序编译中的必备阶段，但却是程序开发中的必经环节。所谓的调试就是让程序试运行并查看程序运行时的各种状态。这个过程当然可以通过直接修改程序代码来实现。比如很多人都喜欢的“print 调试法”，把需要查看的变量直接 print 出来。但这样做非常麻烦，而且有时候程序崩溃得猝不及防，根本来不及 print，这就需要一些专用的调试工具。

* the GNU Project Debugger (GDB)

GDB是一款调试工具，用于查看编译后的 C 程序的运行状态以判断程序是否按照预期正常执行。由于程序从编写到运行的过程中有非常多地方可能出错，反复的运行和检查是保证程序正确执行的关键。虽然现在有一些技术可以通过对代码进行逻辑检查来判断程序能否按预期执行，但这些技术往往具有很高的检查成本。因此运行实验仍旧是最主要的程序检查手段。不过如果你仅仅是编译别人写好的源码，则不一定需要用到GDB，因而GDB在很多Linux发行版中并不默认安装。

GDB 的官网地址为 <https://www.gnu.org/software/gdb/>。

### 阅读资料

* *Stallman, R., Pesch, R., Shebs, S.* (2019). **Debugging with GDB**

这本书是 GDB 参考手册，而非一个简单易懂的教程，其中涉及的语言也不仅仅是 C，所以建议在阅读的时候挑其中一小部分能用上的内容略读就好。对于只需要编译 C 程序的人来说，这个工具完全可以不掌握。对于 C 开发者来说，现在也可以通过各种集成开发环境前端来调用 GDB 打断点，因而使用命令行操作 GDB 的机会其实比较少，相应的系统学习 GDB 的需求也比较低。

