# C 初学指南

这里所要探讨的 C 是一门编程语言，也就是 the C programming language。

## 学习解惑

### 为什么学

C 是目前计算机工程领域最为基础的语言之一。它的基础性地位主要来自于语言的设计和现存项目两方面。设计上它相对接近计算机架构的底层同时又提供了一定的抽象能力，让使用者在获取尽量底层的控制能力的同时可以使用相对简洁的代码；现存项目方面，用这种语言编写的工程项目几乎遍及计算机工程的各个领域，其中最为重要的是目前主要的操作系统和许多“高级语言”的运行时环境程序就是由这种语言编写的。因此，虽然这种语言现在存在包管理不完善、项目构建不方便、语言设计老旧等问题，计算机工程在可预见的未来却不会抛弃这门语言，而会以改进、更新、整合以及继续使用为主。

由于 C 在计算机工程中事实上的基础性设施地位，不论在开发中是否直接用到大量的 C，都应当对这门语言及其相关知识有所了解。

但是，**我个人并不推荐用 C 作为入门计算机时学习的第一语言**。C 是基础的，但这不意味着它是简单的，也不意味着它是易学的，在工程中作为基石和在学习中作为第一课是两码事。那么为什么我还要把 C 放到这个系列中这么靠前的部分呢？因为我写这个系列的时候已经不是入门阶段的初学者了，所以尽量按照知识结构和工程逻辑排布内容，而不是按照学习顺序排列。初学者如果想在这个系列中找到更多适合自己的内容不妨往后翻几章。

### 学什么

个人认为对于不需要大量写 C 代码的人来说，了解C的主要目的是阅读 C 代码和编译由 C 写的项目，基于此，所需要掌握的主要内容如下：

- 标准：C 语言标准和标准库（包括宏和头文件写法）
- 实现：标准库的实现和编译工具链
- 工程：项目源码组织方式和基本构建工具

在这几点之外，还有一个主题是贯穿这几个学习部分的，那就是调用已经写好的库和把自己的工作提炼成新库。

通常来说，作为标准的纯 C 高度绑定于类 Unix 系统以及 GNU 工具链；而其他系统都有替代 C 的主要编程语言（例如 Windows 有 Visual C++，Mac 有 Objective-C）；虽然很多嵌入式编程会用到 C 但往往也对 C 的语法和标准库做了不小的改动，基于这些原因，上边列举的内容将主要在 Linux 和 GNU 的基础上学习。

### 不学什么

目前 LLVM 是一个相当有竞争力的、在多种意义上跨平台的、支持 C 语言的工具链和运行环境。在很多方面 LLVM 都可以与 GNU 的工具链竞争，有的方面 LLVM 甚至走的更远。但由于 LLVM 并非一个仅仅关注 C 语言（乃至并非仅仅关注 C 语系）的项目，这里不将 LLVM 作为 C 语言知识的一部分。

最初的 C++ 作为 C 的超集提出，几乎所有的 C 程序也都是 C++ 的程序。但目前 C++ 已经不堪重负，维持与 C 的一致性也不再是 C 和 C++ 标准委员会的主要目标。因此虽然很多 C 项目也可以使用 C++ 的工具链处理，这里仍然不推荐这种做法，因此不将利用 C++ 工具链的知识作为C语言相关的知识介绍。

### 拓展什么

仅仅凭借 C 语言的基本功能和标准库是难以应对各种编程需求的，因此在了解基本的 C 知识后根据需要了解一些相关的非标注库和框架很有必要。 C 语言与类 Unix 系统高度绑定，甚至一些程序构建和调用也和类 Unix 系统的接口有关，在了解 C 之后首先应当对类Unix的开发做一个大致的了解。如果你在 C 以外还使用其他编程语言，那么了解这些编程语言和 C 的交互方式，熟悉一下它们和 C 的混合编程也是很有意义的。具体到一定的业务场景中，可以按需了解相关的专用库，例如编写 GUI 程序就看看 GTK、做压缩就看看 zlib、做数值计算就看看 GNU Scientific Library (GSL) 等等。

如果你对 C 的需求超出了阅读和编译，需要大量编写 C 代码，那么你还应当对开发工具有所了解，例如常用的调试工具 GDB 。同时，代码风格也是一个应当注意的点，好的代码风格会大大降低代码的维护难度，同时减少出错。但代码风格并不像语言标准那样具有普适性（尤其是对于涉及范围如此广泛的 C 来说），建议阅读一些优质项目的代码风格指南。

## 从哪里学

不仅仅是学编程语言，学很多东西的手段也无非就是阅读和实验。编程的实验条件相对容易达到，根据你习惯的操作系统，按网上或者书上的教程搭建一个开发环境，然后写就是了。阅读呢，一般需要读一些精当的教材，事半功倍。这里我完全按我个人的想法推荐一些阅读材料。

### 核心资料

* *Prata, S.* (2016). **C Primer Plus （第6版） 中文版**

这是我个人非常喜欢的一本 C 教程，也非常适合新手阅读。它不仅仅介绍 C 本身，也讲了很多学 C 的时候应当知晓的，有关于计算机原理、操作系统、Shell、编译和数据结构等方面的知识。但它毕竟不是面向纯粹没有接触过计算机的小白的，因此我建议读过我之前推荐的《编码的奥秘》后再来读这本书。

* *Reek, K.* (2008). **Pointers on C**

虽然这本书的正式译名是《C 和指针》，但这本书不仅仅讲指针，它其实是一本很完备的 C 语言教程。与 *C Primer Plus* 不同的是这本书并不面向纯新手，在阅读它之前应当有一些编程方面的基础知识。这本书在有的方面探讨得也比 *C Primer Plus* 深入些，例如这本书讨论了 C 编译和运行的诸多细节以及C和汇编语言的交互。此外本书的编排也更贴近知识结构本身而非初学者的学习顺序。总得来说，这本书可以作为有一定编程基础的人系统学习 C 的教材（无需从一些特别基础的通用概念学起），也可以供读过 *C Primer Plus* 的人作为进阶教材使用。不过由于很多内容 *C Primer Plus*  和 *Pointers on C* 都讲到了，建议读过前者的人读后者时跳过熟悉的内容以提升阅读效率。

* **cppreference**

这是一个网站，其网址是 <https://en.cppreference.com/w/>，上边有 C 和 C++ 的语言标准说明和标准库参考手册。当你读完 *C Primer Plus* 或 *Pointers on C* 之后就会明白编程仅仅是学语言是不够的，很多功能需要标准库的支持，而标准库的内容又很难全凭记忆记住（也没这个必要），因此一个随时备查的标准库参考就是编程时必不可少的工具。个人感觉买一本书在编程的时候来回翻实在太蠢，所以推荐使用这个在线网站查询。

* *Linden, P.* (2002). **Expert C Programming**

这本书并非完整的 C 教程，而是一些关于C的深入话题的集合，因此我建议在读过 *C Primer Plus* 或 *Pointers on C* 之后挑选部分章节阅读。个人推荐重点阅读书中的第5、6、7章，这三章着重讲解了 C 程序的编译链接过程、编译后程序的运行和计算机硬件的相关知识。这些内容在很多C教程中不作为重点，但对于 C 程序员来说又是非常重要的。此外书中第1章，介绍了C的有关历史沿革，也是很具有趣味性的。如果对 C++ 感兴趣，可以再读一读书中的第11章，做一个大致的了解。

* *Bryant, R., O'Hallaron, D.* (2015). **Computer Systems A Programmer's Perspective**

学习编程很多时候要把功夫下在编程语言之外，这本书就是专门介绍编程语言之外的那些需要学习和了解的内容的。这本书没有讲 C，但是每一章都是 C 编程中可能用到的重要知识，基本上把 C 涉及到的计算机硬件组成、汇编语言、编译、链接、调试、运行环境、操作系统、网络、多线程、异常处理等内容都讲了一遍。其中的很多内容不仅仅适用于 C，在你学习其他语言或者技术的时候也可能用得上。

### 工具和手册

这里列举几个常用的在初学 C 时会接触到的工具。这些工具在之前介绍的资料中有出现。

* the GNU Compiler Collection (GCC)

GCC 是类 Unix 系统中的主要 C 编译器之一。利用它可以把 C 的源码转化为可执行文件。大致的转化流程参见 *Expert C Programming* 等书。其详尽用法参见 GCC 官方手册。

GCC 的官网地址是 <https://www.gnu.org/software/gcc/>。

* GNU Binutils

GCC 是一个编译工具集，在调用 GCC 的时候它会自动调用一系列工具完成编译。如果需要单独使用编译过程中的部分工具或者使用一些二进制文件工具检查生成的可执行文件，你就需要用到 GNU Binutils 了。其中比较常用的组件有`ar`和`ld`。`ar`是二进制文件归档工具，用于创建静态库，`ld`则是链接器（链接器的作用详见 *Expert C Programming* 等书），可用于创建动态库。详尽的使用说明同样见其官方手册。

GNU Binutils的官网地址是 <https://www.gnu.org/software/binutils/>。

* the GNU C Library (glibc)

GCC 和 GNU Binutils 只是 C 的编译链接工具，它们负责将源码转化为可执行文件但 C 的标准库却不由它们实现。GNU 计划中的 GNU C Library 则负责实现 C 标准中的库函数供 GCC 或 `ld` 往编译后的代码中链接。

glibc 的官网地址为 <https://www.gnu.org/software/libc/>。

* the GNU Project Debugger (GDB)

GDB是一款调试工具，用于查看编译后的 C 程序的运行状态以判断程序是否按照预期正常执行。由于程序从编写到运行的过程中有非常多地方可能出错，反复的运行和检查是保证程序正确执行的关键。虽然现在有一些技术可以通过对代码进行逻辑检查来判断程序能否按预期执行，但这些技术往往具有很高的检查成本。因此运行实验仍旧是最主要的程序检查手段。不过如果你仅仅是编译别人写好的源码，则不一定需要用到GDB，因而GDB在很多Linux发行版中并不默认安装。

GDB 的官网地址为 <https://www.gnu.org/software/gdb/>。

### 选读资料

这一部分资料我个人不是十分推荐，但还是值得列出来。

* *Kernighan, B., Ritchie, D.* (2004). **The C Programming Language**

因为 C 的发明者参与了这本书的编写，所以很长时间以来这本书都被捧上神坛。问题在于 C 的最初设计者 Dennis Ritchie 并不是唯一对 C 做出过贡献的人，今日的 C 是标准委员会、各工具链开发商和世界各地的 C 程序员共同造就的——就像 Linus Torvalds 并非独自一人完成的今日之 Linux。因而秉持英雄史观将最初设计者参与编写的书捧上神坛并不明智。例如全书按照语言设计的思路编写，而较少考虑读者的接受能力，这对于初学者来说这本书就相当不合适。此外，这本书几十年不更新，这并不是一个好事。对于计算机工程相关的项目来说，更新就是其生命力，哪怕核心内容不做改动，不断对新发展趋势做出回应也是必须的。就算最初设计的再合理，几十年沧海桑田，也会慢慢消磨掉最初的设计优势，工程上根本没有所谓的一劳永逸。

当然了，虽然这本书不应该被强行吹上神坛，它也并非一无是处，实际上这本书在众多 C 教材中算得上是非常优秀的佳作。这本书的一个比较突出的特点就是会在书中介绍很多 C 在设计和实现中的细节，例如`printf`和`malloc`这种标准库函数是怎么实现的。此外，这本书也很重视语言和系统之间的关联性，专门用了很多篇幅介绍了 C 和类 UNIX 系统的互动。因此，个人认为这本书的适合人群主要是已经对计算机有所了解，想要比较系统深入地了解 C 的人。当然读者最好还有一定的知识检索能力，能在阅读后自己拓展有关 C 的最新内容，以弥补本书几十年不更新的缺憾。

* *Koenig, A.* (2008). **C Traps and Pitfalls**

这本书中文译名《C 陷阱与缺陷》，是作者根据其一篇论文扩写而来，所以篇幅很短，可以很快读完。这本书主要列举了 C 的若干可能引发错误的特性以及缺陷。个人认为这又是一本被强行捧上神坛的书。在这本书写作的时候书中的很多内容是非常具有启发意义的，但几十年过去了，C 的很多陷阱和缺陷已经普遍为人们所知。实际上这本书中提到的大部分内容在 *C Primer Plus* 中都讲到了。如果你选择了一本比较新的 C 教材，可以不读这本书。

不过，这本书还是很有教育意义的，因为在看到C语言中的如此多缺陷和陷阱之后，我更加坚定地认为最好的使用 C 的方式就是尽量不使用 C。另外书中的建议也十分中肯，使用最安全稳妥的做法实现程序就好，不要过分探索一门满是缺陷的语言的缺陷，毕竟编程不是耍杂技。

* *Hanson, D.* (2016). **C Interfaces and Implementations: Techniques for Creating Reusable Software**

这本书的重点有两个，一个是介绍如何写方便复用的 C 代码，这其中主要的就是利用C现有的机制将接口描述和实现分开，另一个就是实现了一些通用的数据结构、算法和工程处理方法作为样理。

其中，第一个重点受限于 C 非常不完善的语言功能，显得异常晦涩困难;第二个重点的内容放到现代一些的语言里其实根本没必要，因为大部分都已经被标准库实现了。因此，对于不想从事非常深入的 C 开发的人来说这本书没什么必要读。


