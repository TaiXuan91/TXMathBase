# 0X19 分数

我们用扩张的办法构造出了加法群。同样可以用扩张的办法，基于乘法半群得到一个乘法群。把运算对象从全体正整数扩张到全体正分数我们就能得到一个乘法群。这里我们要先解释一下分数。为了说明分数，我们最好先回忆一下有序的概念。

全体正分数的集合其实等于全体正整数集合对自身的笛卡尔积，也就是cartesian(Pos,Pos)（设全体正整数记为Pos）。分数的记法也可以看作是另一种有序对的写法。比如你可以把“3/4”写成“(3,4)”。这个例子里前边的3称为分子，后边的4称为分母。分母为1的分数就是整数。从这个角度看我们的整数2，3，4等是(2,1),(3,1),(4,1)的简写。

## 约分

在分数之间可以建立一种等价关系：如果一个分数可以由另一个分数在分子和分母上同时乘以一个非零整数得到。那么二者相等。

在这种等价之下(1,2),(2,4),(3,6)都是相等的。而且还有无数个分数和他们等价。在只允许整数作为分子，只允许非零整数作为分母的情况下，这一堆等价的分数中不存在分子（或者分母）绝对值最大的。但是存在分子（或者分母）绝对值最小的。例如这里的(1,2)就是这种情况。我们就称(1,2)为它们的既约形式（存在负号的时候，习惯让负号在分子里）。一个分数的等价写法有无数种，但是等价的既约形式只有一种。把其他形式化为既约的过程称为约分。

由于我懒，所以这里就不给出具体的约分算法了。如果你实在不会约分，可以用Python的fractions模块来约分。这个模块创建分数后会自动约分：

```python
from fractions import Fraction
x=Fraction(24,36)
print(x)
```

由于既约形式的唯一性。我们一般都把分数运算结果用既约形式表示，以节省存储空间，并且方便比较和判断。

## 分数乘法

接下来我们把乘法从正整数扩展到正分数。分数乘法就是把两个分数的分子分别相乘作为运算结果的分子，把两个分数的分母相乘作为运算结果的分母（一般在运算完成后还会对运算结果进行约分）。

正分数乘法是构成群的。首先分数乘法和整数乘法一样是满足结合律的。

第二，1（或者说(1,1)，1/1）仍然是分数乘法中的单位元。

第三，对于任意正分数。他的乘法逆元就是它的倒数。对于一个分数来说，它的倒数就是用它的分子作为分母，分母作为分子形成的分数。

## 负分数

分数也有正负。正分数和负分数的乘法运算，是整数乘法运算的扩展。两个分数相乘，如果正负号相同，则结果是正分数。如果正负号不同则结果是负分数。

全体正分数和负分数构成的集合以及其乘法运算也构成一个群。需要注意的是负分数的倒数（乘法逆元）仍然是负分数，-1的逆元就是-1，1的逆元就是1。

## 0的特殊性

现在我们还有一个自然数没有考虑进来——0。0的规定具有特殊性。首先，在构成分数的时候它不能作为分母。但是可以作为分子。并且0作为加法不变元，在乘法中也享有一项特权——任何数乘以0都等于0。

简单来说，0的这些特殊性是我们构造这个系统时候的人为规定。如果不这么规定，我们难以把这个数学系统用到实际的计算中去。而且如果不这么规定会导致很多矛盾。

稍微深入一点来说。这么规定是为了让有理数能成为一个“域”结构。如果没有“0乘任何数都等于0”。那么分配律就有失效的危险。比如0乘一个数a不等于0,而等于不为0的b。那么cdot(a,plus(1+0))就不能按分配律展开乘为plus(cdot(a,1),cdoc(a,0))。展开前的结果是cdot(a,1)得a，而展开后成为了plus(a,b)和a不相等。

基于任何数乘以0都得0。我们就会发现，乘以0这个运算有信息丢失，是不可逆的。仅仅根据乘积结果0，和因子0无法确定另一个因子是什么。如果非要除，那么得出的结果不应该是一个数，而应该数全体有理数（因为任何一个有理数都有可能是另一个因子）。这就又破坏了四则运算的封闭性。综合考虑这些因素，规定0不能做除数是一个简单有效的方案。

另外，极限理论里。有时候会把0写在分母的位置。需要注意的是，这并不是让0作为了分母。而是“在不引起混淆的情况下的简写”。0做分母的那些式子，都是分母趋于0的缩写。完整写出来是一个求极限过程。由于具体求极限的函数不同，最终的结果会有所不同。如果你硬要把这认为是0做了分母。你就会发现这个“0做分母”的情况，一会等于0，一会等于无穷大，一会等于任意常数。数学就会被你学成玄学。
