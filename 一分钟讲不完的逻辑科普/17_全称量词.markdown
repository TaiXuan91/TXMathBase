# 全称量词

**古之人，损一毫利天下，不与也，悉天下奉一身，不取也。——《列子·杨朱》**

之前的章节中我们引入了自由变量，但是自由变量存在一些问题，例如变量的重名。假设有两个语句(G x)和(H x)，这是两个不用联词联结且没什么关系的单句，那么这两个句子中的“x”是否应当指同一个对象呢？显然是不必要的。例如“这是个男人”和“这是个女人”，这两个句子里都用了代词“这”，但是显然这两个句子中的“这”并不需要指同一个对象。

## 受囿变量

“受囿”就是“被约束”的意思，“受囿变量”就是“被约束的变量”。我们之前引入的变量称为自由变量，无拘无束，可以指带任何一个对象并且作用域覆盖全文。这个“作用域覆盖全文”就是指一段证明中所有出现这个变量的地方都指同一个变量（虽然可以指任何一个对象，但是要保证每次解释这个变量的时候必须把所有相同的变量解释为一个意思，任意性指体现在用于替换变量的对象的选取上）。这个我们之前的章节已经做过解释。而受囿变量就是给自由变量加上了一定的约束。给一个变量加上约束后，这个约束给变量指定一个作用域（作用域实际上也就是文本中的一个区域），在作用域中这个变量的每一次出现都表示同一个对象，而作用域外这个变量的含义就不受约束了。

我们约定一个新符号“∀”，用它来表示对变量的约束。假设有：

> x::Variable
>
> H::Predicate ::= “有细长柄”
>
> J::Predicate ::= “能用来挠痒痒”

我们就用“∀x”来表示对变量x进行约束。在“∀x”后接一对括号，括号内就是对变量约束的作用域。例如一个完整的带受囿变量的语句应该是这样：

> ∀x((H x)⇒(J x))

这个约束的作用域就包括“(H x)⇒(J x)”，因而虽然x可以指代任何一个对象，但是用具体对象替换x的时候“(H x)”中的x和“(J x)”中的x需要替换为同一个对象。在实际的书写中，对于受囿变量，我们一般省略“x::Variable”这一约定。也就是直接这样写：

> H::Predicate ::= “有细长柄”
>
> J::Predicate ::= “能用来挠痒痒”
>
> [1] ∀x((H x)⇒(J x))

注意我们给“∀x((H x)⇒(J x))”加上了标号，因为它也是一个语句（尽管加上了对变量的约束，它仍然是一个语句）。需要说明的是，“∀x((H x)⇒(J x))”和“(H x)⇒(J x)”并不是同一个语句。那么这个语句应该怎么翻译为自然语言呢？把“∀”读作“所有”，把“∀x”读作“对于所有x”，“∀x((H x)⇒(J x))”整个句子读作“对于所有x，x有细长柄蕴含x能用来挠痒痒”。

那么变量是否受约束到底会对句子的语义产生什么样的影响呢？比较这两个语句：

> A::Predicate ::= “是圆的”
>
> B::Predicate  ::= “是方的”
>
> C::Predicate ::= “是三角”
>
> [1] ∀x((A x)∨(B x)∨(C x))
>
> [2] ∀x(A x)∨∀x(B x)∨∀x(C x)

[1]和[2]看起来所有变量，谓词都一样，但是句意是非常不一样的。我们先不论其真假，看看它们分别在说什么。[1]表达的是“对于任何一个东西，它是圆的，方的或者三角的”，当然由于析取词的特性，它也可以同时是圆的，方的和三角。在这个语句的含义下，可以有一些东西是圆的（但不是方的），同时存在另一些东西是方的（但是不圆）。而[2]表示或者所有东西都是圆的，或者所有东西都是方的，或者所有东西都是三角的。析取词的特性无法表现在各种物体的形状多样性上，所有东西都是一个形状，只不过它们可以同时是圆、方、三角。因而在这个语义下，当存在一些只圆不方的东西时，所有东西都应该是只圆不方的，没有只方不圆的东西存在。

## 受囿变量的替换

我们之前介绍过，名词只不过是一个占位符，它具体怎么写并不是很重要，只要能区分彼此，把对象的定义和对象的性质联系起来就可以。受囿变量也有类似的性质，我们可以将一个约束及其作用域内同一个受囿变量的所有出现同时替换为另一个变量。例如：

> [1] ∀x((H x)⇒(J x))
>
> \# 把所有的x替换为y
>
> [2] ∀y((H y)⇒(J y)) (1, x|>y)

我们将语句“∀x((H x)⇒(J x))”中约束处“∀x”的“x”和约束作用域内的“x”全部替换为“y”，得到“∀y((H y)⇒(J y))”。这样的替换并不会影响语句的真假。例如把“如果这东西有细长柄，那么这东西能用来挠痒”替换为“如果那东西有细长柄，那么那东西能用来挠痒”，语义并没有太大改变。除了“这”和“那”体现出来的被指代物距离说话者的距离变化以外，这两句话都是在说如果一个东西有细长柄，那么可以用来挠痒。

受囿变量的替换，在一些情况下其实有可能引起语义的改变，为此有一整套规则用于对受囿变量替换加以约束。由于这是一个科普性质的系列，这一部分我们暂且不讨论，感兴趣的话可以阅读更为严谨的数理逻辑教程了解。

## 全称列举

之前我们讨论过，逻辑中的“联词”和自然语言中的“联词”其实不完全是一回事。现在我们要说的这个“量词”也不是自然语言中的“量词”。自然语言中“个”，“米”，“度”等用于度量的词汇是量词。而逻辑上的量词是用来限制代词的指代的。我们之前介绍的“∀”就是一个量词，它称为全称量词（除此以外我们之后还会介绍一个存在量词“∃”）。

那么为什么这些限制代词的词要叫量词呢？不妨这样想，用一个筐把所有量词能指代的对象全部装进去（这个筐应该是挺“大”的），从筐里拿出一个对象是一个量，拿出两个也是一个量，拿出一半来也是一个量。既然1是量，2是量，一半是量，那要是全拿出来，“全部”也算一个量。而全称量词，说明从这个筐里取出任何一个对象来顶替到被约束的变量的位置，句子都成立。因而，这个代词指代对象的范围是全部对象。我们把“全部”当作一个量的话，叫“∀”量词似乎也就比较合理了。

这里我们已经不知不觉引入了一条关于全称量词的推理规则。如果我们说“所有山上都有石头”，那么我们自然可以由此得出任何一座具体的山上都有石头，例如“泰山上有石头”，“喜马拉雅山上有石头”，“嵩山上有石头”等等。这叫做全称列举，英文名为“Universal Instantiation”，简记为U.I.。在介绍它的形式化表达之前我们需要再约定一些记法，说明一些细节。

对于任何一个语句A（也就是A::Formula），不管它的主谓构成是怎样，也不管其中带不带量词和变量，在它之前加上对某个变量的全称约束后仍然是一个语句。为了简便我们记这个语句为“∀x(A)”（其中“∀x”就是新增的约束）。另外我们约定一个新的写法，用"(A|x|>y)"表示把语句A中所有x替换为y之后得到的语句。接下来我们给出U.I.的形式化表示：

> x::Variable
>
> y::Noun
>
> ∵ ∀x(A) ∴ (A|x|>y)

这里x必须是一个变量，y必须是一个名词，因而我们在表述之前额外加上了对类型的说明。U.I.就是在说如果全称命题（含有全称量词的命题）为真，把全称量词约束去掉并且把被约束变量的所有出现都替换为一个名词，得到的语句也为真。

举个例子，已知“所有人都会死”，这个句子可以这样形式化。

> H::Predicate ::= “是人”
>
> J::Predicate ::= “会死”
>
> [1] ∀x((H x)⇒(J x))

我们再约定一个名词“苏格拉底”。

> a::Noun ::= “苏格拉底”

那么可以利用U.I.做一步证明：

> [2] (H a)⇒(J a) (1, U.I.)

我们得到的语句[2]实际上就是在说“苏格拉底是人蕴含苏格拉底会死”，也就是“如果苏格拉底是人，那么苏格拉底会死”。注意这是一个蕴含语句，如果能证明苏格拉底不是人，那么他就有希望逃脱死亡。

## 全称概括

现在我们要对上一章中含有自由变量的语句做一个处理。从翻译成的自然语言语句来看，一个含有自由变量的语句表达的意思似乎和用全称量词约束过的版本差不多。例如“一个对象是人蕴含这个对象会死”和“对于所有对象，这个对象是人蕴含这个对象会死”似乎是一个意思。但是在形式上两者写法是不同的，一个是“(H x)⇒(J x)”，另一个是“∀x((H x)⇒(J x))”。我们只能将U.I.用于“∀x((H x)⇒(J x))”，但是“(H x)⇒(J x)”不符合U.I.的使用前提。

为此我们引入一条新的推理规则——全称概括（英文名为“Universal Generalization”，简记为U.G.）。U.G.可以把“(H x)⇒(J x)”转化为“∀x((H x)⇒(J x))”。其形式表示为：

> y::Variable
>
> A::Formula
>
> ∵ A ∴ ∀x(A|y|>x)

这里A是一个语句，y必须是一个自由变量。如果语句A为真，将语句A中的自由变量y替换为一个受囿变量之后得到的语句也为真。这个变换在自然语言中确实不多见，主要用于形式逻辑中做形式转换。例如：

> \# 前提
>
> x::Variable
>
> [1] (H x)⇒(J x)
>
> \# 将自由变量x替换为x本身然后加约束也是可以的
>
> [2] ∀x((H x)⇒(J x)) (1, U.G.)

实际上我们也能把带全称量词的语句变成带自由变量的语句。这需要给U.I.再加一项：

> x::Variable
>
> y::Variable
>
> ∵ ∀x(A) ∴ (A|x|>y)

注意，这一项里要求y必须是自由变量。那么这么转换来转换去有什么意义呢？这是为了把带全称量词的语句转化为不带全称量词的语句，从而使得其形式可以套用之前的命题逻辑推理规则。例如我们可以从“所有动物都会死”和“所有人都是动物”证明出“所有人都会死”。证明过程这样写：

> \# 词汇约定
>
> H::Predicate ::= 是动物
>
> J::Predicate ::= 是人
>
> K::Predicate ::= 会死
>
> \# 前提
>
> [1] ∀x((J x)⇒(H x))
>
> [2] ∀x((H x)⇒(K x))
>
> \# 证明
>
> y::Variable
>
> [3] (J y)⇒(H y) (1, U.I.)
>
> [4] (H y)⇒(K y) (2, U.I.)
>
> [5] (J y)⇒(K y) (3, 4, H.S.)
>
> \# 结论
>
> [6] ∀x((J x)⇒(K x)) (5, U.G.)

现在我们证明了“所有人都会死”，距离封面图上的证明还有一步之遥了。

## 讨论

如果读过Copi书中对应章节不难发现我这里使用的符号又和书中不太一样。其中用“∀”表示全称量词是数学上常用的表示。但关于符号替换的记法是我在这个系列专栏中临时约定的。

关于符号替换，其实有很多限制规则。这些规则主要就是要保证不导致谬误。不过眼下我们只是作科普性的介绍，处理的情况相对简单，遇到这种谬误的概率比较小，所以我省略了这部分规则的介绍。但是这些规则是逻辑中不可或缺的部分，建议对逻辑有一个基础的认识之后，进一步读一些研究的数理逻辑教材，补充这一部分的知识。当然了，一个比较简单的避免因为符号替换带来的错误的方法就是尽量不要使用重复的符号，从而减少因为符号冲突而需要替换变量名的情况。反正我们加入代词类型声明后，不需要用字母的写法来区分类型，可以把变量名写得很长。
