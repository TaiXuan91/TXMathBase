# 0X32 ZFC形式语言说明

## 前驱

* 0X31 集合的表示

## 说明 1

由于目前我们还没有正式讨论数理逻辑的形式语言所以ZFC所必须的形式语言部分我们以描述说明的形式介绍。

在集合论当中我们使用如下几类符号：

1. 用小写字母如$x,y,z$或者大写字母如$X,Y,Z$表示集合变元。这里所谓的“变元”是指这些符号可以被任何一个符合语句中限制的集合替换而不改变语句的真假。
1. 属于关系符号$\in$。
1. 等于关系符号$=$。（应当注意，等词是一个在逻辑中定义的谓词。如果两个符号存在“等于”关系，那么可以在任何语句中让这两个符号相互替换而不改变语义和语句的真假。）
1. 逻辑符号：$\vee,\wedge,\neg,\implies,\iff,\forall,\exists$
1. 技术性符号（用于调整运算顺序，防止混淆，使得公式更为简便）：左右圆括号。

## 说明 2

【ZFC中公式的形成规则】

首先是三种简单的原子公式的生成：

1. 单独的一个集合变元是一个公式。
1. 两个集合变元由$\in$连结是一个公式。如$x\in y$。
1. 两个集合变元由$=$连结是一个公式。如$x= y$。

然后是带量词的公式：

1. 如果$A(x)$表示一个命题，并且$x$在其中自由出现。那么$\forall xA(x)$和$\exists xA(x)$都是公式。并且变元$x$在$\forall xA(x)$和$\exists xA(x)$中约束出现。

所谓$x$在$A(x)$中自由出现，就是说$A(x)$中不存在$\forall x$和$\exists x$这样的对$x$的约束。如果$let(B(x)=(\forall A(x)))$那么$x$在$B(x)$中就是约束出现。

接下来是用逻辑联结词生成的公式：

1. 如果$A$和$B$是ZFC中的公式，那么$(\neg A),(A\vee B),(A\wedge B),(A\implies B),(A\iff B)$都是ZFC中的公式。

如果一个变元在$A$中自由出现，那么在$(\neg A)$中也自由出现。如果一个变元在$A$或$B$中自由出现那么也在$(A\vee B),(A\wedge B),(A\implies B),(A\iff B)$中自由出现。

在任何公式中，不引起混淆的情况下左右圆括号可以省略（比如最外层包括整个公式的括号一般省略）。

## 说明 3

在ZFC中，如果一个ZFC的公式中没有任何自由出现的变元，我们称这个公式为命题。

ZFC中任意一个变元，定义的集合（一个具体的集合）或者集合经函数运算的结果（仍然是个集合），称为一个“项”。

如果$A(x)$是一个公式，其中$x$自由出现。而$t$是一个项。那么$A(t)$就表示把$A(x)$中所有自由出现的$x$替换为$t$的结果后得到的公式。

## 说明 5

【逻辑公理】

一个逻辑系统主要有两套规则，一套说明什么样的字符串是这个系统中的公式，称为形成规则（或者生成规则）；另一套说明命题之间的推演运算关系。

首先是根本性的规则——三条形式推演规则（在张锦文《公理集合论》中把这三条单列出来，但是我们认为它们是逻辑公理也可以）。

（$A,B$表示ZFC中的公式。$A(x)$表示一个包含自由出现的变元$x$的公式。$t$是ZFC中的一个项。）

1. 从$A\implies B$和$A$为真可以推演出$B$为真（这一条也称为“分离规则”）。其中$A\implies B$称为大前提，$A$称为小前提。
1. 从$B\implies A(x)$为真可以推演出$B\implies \forall xA(x)$为真。
1. 从$A(t)\implies B$为真可以推演出$\exists xA(x)\implies B$

为了适用于分离规则，以下逻辑公理全部是蕴含式的形式：

（$A,B,C$表示ZFC中的公式。$x$是变元。$t,s$是都表示项。）

1. $A\implies (B\implies A)$
1. $(A\implies A)\implies ((A\implies (B\implies C))\implies(A\implies C))$
1. $A\implies (B\implies (A\wedge B))$
1. 有两种形式：
    * $(A\wedge B)\implies A$
    * $(A\wedge B)\implies B$
1. 有两种形式：
    * $A\implies (A\vee B)$
    * $B\implies (A\vee B)$
1. 有两部分：
    * $(A\iff B)\implies ((A\implies B)\wedge(B\implies A))$
    * $((A\implies B)\wedge(B\implies A))\implies (A\iff B)$
1. $(A\implies C)\implies  ((B\implies C)\implies((A\vee B)\implies C))$
1. $(A\implies B)\implies((A\implies \neg B)\implies \neg A)$
1. $\neg\neg A\implies A$
1. $\forall xA(x)\implies A(t)$
1. $A(t)\implies \exists x A(x)$
1. $\forall x(x=x)$
1. $(t=s)\implies(A(t)\implies A(s))$

以上公理既是ZFC系统推理时的规则，也可以作为ZFC中一些定理证明时的前提。

注意以上公里中除了第12条$\forall x (x=x)$以外，其他都是公理模式。

## 说明 6

在说明5中的形式推演规则3，需要说明一下。

>从$A(t)\implies B$为真可以推演出$\exists xA(x)\implies B$

变元$x$约束出现于$\exists xA(x)$中，但不一定出现于$B$中。并且$x$可以是讨论范围内任何一个集合。同样，这里的$t$仅仅存在于A中，而不一定存在于B中。并且注意项$t$是可以在整个讨论范围内任意选择的。虽然我们称$t$是一个项，但是它仍然能随意取值。（这里“$t$代表一个项”，就说明它其实是一个“项的变元”，也就是说可以用任何一个项来代替$t$。“项的变元”可以用集合变元，定义的集合或者输出集合的函数表达式来替代。而一般的集合变元只能用集合来替代。）

我举一个典型的**误解**的例子。

假设情景是这样，一个工厂有好几个锅炉。一个工人负责一个锅炉。谁负责的锅炉坏了就要扣工资。其中Tom负责1号锅炉。那么如果1号锅炉出问题，Tom就要被扣工资。但是其他锅炉出问题了Tom不用被扣工资。

如果你**误解**了上边的形式推演规则。可能会认为从“$1$号炉子坏了$\implies$Tom被扣工资”可以导出“有炉子坏了$\implies$Tom被扣工资”。

这就是一种忽视“$t$的任意性”造成的错误。前提中仅仅有“$1$号炉子坏了”，不能直接替换成“$t$号炉子坏了”。因为原来给的前提中没有说明$2,3,4,5$等炉子坏了的情况，所以$t$并不能随意地取$2,3,4,5$等值，还保证能导出“Tom被扣工资”的结果。

说到这里可能有人有疑问“既然遍历所有值为什么不用全称量词呢？”

如果使用了全程量词，那么推演规则变成了“从$\forall tA(t)\implies B$为真可以推演出$\exists xA(x)\implies B$”的**错误**形式。举个例子，这就相当于从“如果锅炉全坏了，今天工厂就休息”推出了“如果有锅炉坏了（不管几个），今天工厂就休息”。

事实上一个正确使用推演规则3的例子是这样：从“$t$号炉子坏了（$t$号可以是任何一个炉子）坏了就要有人扣工资”推出“存在炉子坏了就存在有人扣工资”。区别在哪里呢？区别在于把项换成了约束变元。

总结一下，项就可以看作是一个自由变元。但是不管怎么自由对于$A(t)$来说，它只表示“一个元素$t$满足条件$A(t)$”。虽然$t$的选择是任意的，但是没有办法保证在选择了$t$为某一个值之后其他对象的情况。而全称量词要求全体可能的对象同时满足条件。

（“项”的问题和“模式”有一定关系。不管用全程量词还是存在量词，没有自由变元的公式都不是“模式”。也就是说它们都仅仅是一条命题。例如$\forall xA(x)$虽然规定了所有$x$都有性质$A(x)$但是，仍然只是一个命题。而含有自由变元就相当于同时书写了很多命题，然后从中选一个。比如$A(t)$，实际上表示$A(1),A(2),A(3)$等等等等。而$A(t)\implies B$说明从$A(1),A(2),A(3)$中任意选择一个都能用于证明$B$。所以含有自由变元的命题实际上是“命题的变元”（和集合变元不是一个层面的问题）。）

## 后续

关于含有自由变元的公式的意义感觉没有说清楚。展开介绍数理逻辑的时候重新梳理一下并且把这章精简一下。