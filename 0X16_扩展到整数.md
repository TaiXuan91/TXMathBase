# 0X16 扩展到整数

## 自然数加法半群

根据对自然数加法运算plus的定义，这个运算具有结合律（根据“x的后继数加y等于y的后继数加x”可以证明）。

所以自然数和其上定义的加法运算构成半群。

但是更进一步讨论，这个代数系统并不是群。群在半群的基础上还有两个要求——存在单位元，所有元素都有逆元。

自然数中存在加法的单位元0。但是除了0以外，其他元素在自然数集合中都没有加法逆元。

## 负数的引入

既然自然数和自然数加法本身不是群。我们可以对自然数进行扩充，获得一个符合群定义的代数系统。

引入的负数是当作自然数的逆元用的。所以加法单位元0本身不需要另一个逆元。对于除了0以外的每一个自然数，我们都引入一个负数。

我们用自然数的符号前边加上负号“-”来表示这个自然数对应的负数。比如“3”对应的负数是“-3”。

我们规定，一个自然数和其对应的负数的加和等于加法单位元0。这样全体自然数和全体非0自然数对应的负数共同组成的集合就能用于构成一个群。我们称这个集合为整数集合。其中除了0以外的自然数是正数，0不是正数也不是负数。

为了和之前定义的符号一致，我们这里赋予neg函数另一个意义——求加法逆元。例如neg(3)表示3的加法逆元-3。而neg(-3)就又表示3。neg(neg(3))的结果也是3。而neg(0)的结果仍然是0。

## 绝对值

现在引入一个新的函数，求绝对值函数abs。当输入是一个自然数的时候，它的输出等于输入。当输入是一个负数的时候，它的输出等于输入的加法逆元。例如abs(3)就是3，abs(-3)结果也是3，abs(0)结果是0。

abs函数的输入可以是整数，但是输出的值域是自然数。

绝对值是一种模量，但是现在我们不深究，以后会进一步讨论。

## 整数加法

两个整数相加。如果两个加数都是自然数，那么一切加法规则不变。但是，加法中出现了负数的情况我们还没有详细讨论。

首先根据负数的定义，如果相加的两个数一正一负，并且绝对值相等。那么结果等于0。

第二，为了保持0作为单位元，任何负数加0也依旧等于这个负数本身。

第三，为了保证neg(plus(a,b))等于plus(neg(a),neg(b))。两个负数相加，结果等于这两个负数的绝对值相加然后 再取绝对值和的加法逆元。

需要重点讨论的就是两个绝对值不等的，一正一负加数的相加。首先要比较谁的绝对值大。绝对值大的一方可以拆成部分。一部分正好抵消了另一个加数，另一部分则剩下来作为和。例如-7加3。-7可以分解为-3加-4。-3加3得0。最终得结果就是-4。

顺便提一句负负得正，neg(plus(a,b))等于plus(neg(a),neg(b))这些性质也都是群的性质。可以由群的定义证明。

## 减法运算

通过组合求逆运算和加法运算，我们可以定义减法运算minus。它有两个输入参数。第一个称为被减数，第二个称为减数。被减数减去减数就等于被减数加上减数的加法逆元。由于二者关系密切，我们实际用的算术符号中，取反运算和减法运算是同一个符号“-”。但是有些时候（比如在某些编程语言中）还是要把两者区分开的。

通过求逆运算，我们可以把减法当成加法来看待。但是不管怎么看，不论你是把绝对值大的一方做拆分还是逆用加法表，还是背“减法表”，用“借位法”，本质和加法的运算一样都是查表替换。只不过要查的这个表非常简单，查表算法也很简单。所以用熟了之后也感觉不出来是在用算法。后续的乘法，除法，开方甚至是微积分运算大部分也都是查表替换。虽然表的复杂度，算法复杂度都上升了，但是本质和算加减是一样的。

具体的算法我打算先略过，以后可能会探讨一下如何通过补码用加法实现减法。如果你是不会借位法算减法的话，可以用计算器来算。毕竟会算减法的人很多，但是他们又不是都会编程。
